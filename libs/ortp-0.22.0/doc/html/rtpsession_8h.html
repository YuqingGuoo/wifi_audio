<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>oRTP: include/ortp/rtpsession.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>include/ortp/rtpsession.h File Reference</h1>
<p>The RtpSession api.  
<a href="#_details">More...</a></p>
<code>#include &lt;ortp/port.h&gt;</code><br/>
<code>#include &lt;ortp/rtp.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="payloadtype_8h_source.html">ortp/payloadtype.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="rtpprofile_8h_source.html">ortp/rtpprofile.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="sessionset_8h_source.html">ortp/sessionset.h</a>&gt;</code><br/>
<code>#include &lt;ortp/rtcp.h&gt;</code><br/>
<code>#include &lt;ortp/str_utils.h&gt;</code><br/>
<code>#include &lt;ortp/rtpsignaltable.h&gt;</code><br/>
<code>#include &lt;ortp/event.h&gt;</code><br/>

<p><a href="rtpsession_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__JBParameters.html">_JBParameters</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__JitterControl.html">_JitterControl</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__WaitPoint.html">_WaitPoint</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__RtpTransport.html">_RtpTransport</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__OrtpNetworkSimulatorParams.html">_OrtpNetworkSimulatorParams</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__OrtpNetworkSimulatorCtx.html">_OrtpNetworkSimulatorCtx</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__RtpStream.html">_RtpStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__RtcpStream.html">_RtcpStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__RtpSession.html">_RtpSession</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fd8198a7297a09a67e4d52851366bdf"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_flag" ref="a5fd8198a7297a09a67e4d52851366bdf" args="(session, flag)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_set_flag</b>(session, flag)&nbsp;&nbsp;&nbsp;(session)-&gt;flags|=(flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86766b15b3f7cb3c4b17dd0e7767ad5c"></a><!-- doxytag: member="rtpsession.h::rtp_session_unset_flag" ref="a86766b15b3f7cb3c4b17dd0e7767ad5c" args="(session, flag)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_unset_flag</b>(session, flag)&nbsp;&nbsp;&nbsp;(session)-&gt;flags&amp;=~(flag)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__JBParameters.html">_JBParameters</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a045ce176ebe9323b1e7574e35c5fc777">JBParameters</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4205699e0555a63bd81af2586497c034"></a><!-- doxytag: member="rtpsession.h::JitterControl" ref="a4205699e0555a63bd81af2586497c034" args="" -->
typedef struct <a class="el" href="struct__JitterControl.html">_JitterControl</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>JitterControl</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8610e15ff6f0d81dafb6aabc7509637"></a><!-- doxytag: member="rtpsession.h::WaitPoint" ref="ae8610e15ff6f0d81dafb6aabc7509637" args="" -->
typedef struct <a class="el" href="struct__WaitPoint.html">_WaitPoint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>WaitPoint</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae11f0980998cf9047234a410493fb944"></a><!-- doxytag: member="rtpsession.h::RtpTransport" ref="ae11f0980998cf9047234a410493fb944" args="" -->
typedef struct <a class="el" href="struct__RtpTransport.html">_RtpTransport</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>RtpTransport</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c436ea11700f00fc5f1ad8e70b2eb5b"></a><!-- doxytag: member="rtpsession.h::OrtpNetworkSimulatorParams" ref="a7c436ea11700f00fc5f1ad8e70b2eb5b" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="struct__OrtpNetworkSimulatorParams.html">_OrtpNetworkSimulatorParams</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>OrtpNetworkSimulatorParams</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a066443a1af99e13facf1d79b5e7ee133"></a><!-- doxytag: member="rtpsession.h::OrtpNetworkSimulatorCtx" ref="a066443a1af99e13facf1d79b5e7ee133" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="struct__OrtpNetworkSimulatorCtx.html">_OrtpNetworkSimulatorCtx</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>OrtpNetworkSimulatorCtx</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25eecf17321ed86bb56493637aba3ca6"></a><!-- doxytag: member="rtpsession.h::RtpStream" ref="a25eecf17321ed86bb56493637aba3ca6" args="" -->
typedef struct <a class="el" href="struct__RtpStream.html">_RtpStream</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>RtpStream</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38544b17566b8a97abd18f12e1060af4"></a><!-- doxytag: member="rtpsession.h::RtcpStream" ref="a38544b17566b8a97abd18f12e1060af4" args="" -->
typedef struct <a class="el" href="struct__RtcpStream.html">_RtcpStream</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>RtcpStream</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a904e0759e2d9ec2f67f6c63dfd0dbb66"></a><!-- doxytag: member="rtpsession.h::RtpSession" ref="a904e0759e2d9ec2f67f6c63dfd0dbb66" args="" -->
typedef struct <a class="el" href="struct__RtpSession.html">_RtpSession</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>RtpSession</b></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>RtpSessionMode</b> { <b>RTP_SESSION_RECVONLY</b>, 
<b>RTP_SESSION_SENDONLY</b>, 
<b>RTP_SESSION_SENDRECV</b>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC <a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a669759d404518c7d77e86fe968f8055c">rtp_session_new</a> (int mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a3204997f541c6f5a899da18029493ef8">rtp_session_set_scheduling_mode</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int yesno)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a8887542ffcaaafdb6ae7157f267a6aca">rtp_session_set_blocking_mode</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int yesno)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#af3ca23d5f71565793204d6550860fecd">rtp_session_set_profile</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, <a class="el" href="struct__RtpProfile.html">RtpProfile</a> *profile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aafa271cc4f55c2905097524e4c1c059d">rtp_session_set_send_profile</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, <a class="el" href="struct__RtpProfile.html">RtpProfile</a> *profile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a5afbdbcf00b48fe763fe3dfec28bbccc">rtp_session_set_recv_profile</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, <a class="el" href="struct__RtpProfile.html">RtpProfile</a> *profile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC <a class="el" href="struct__RtpProfile.html">RtpProfile</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a1b34ab1de41bb00744e8406c0fa8a924">rtp_session_get_profile</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC <a class="el" href="struct__RtpProfile.html">RtpProfile</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#acf5fabd53db6e9894893968609397f0a">rtp_session_get_send_profile</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC <a class="el" href="struct__RtpProfile.html">RtpProfile</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a3593bfda1342853369bba062507fa7be">rtp_session_get_recv_profile</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a754c06f3ed87366c0dddc8f4e5481e9d">rtp_session_signal_connect</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const char *signal_name, RtpCallback cb, unsigned long user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#af28f1230c4f1e6f77381cd4dac45c950">rtp_session_signal_disconnect_by_callback</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const char *signal_name, RtpCallback cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aba7a1104bd2a47faf0f7e08f084162d0">rtp_session_set_ssrc</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint32_t ssrc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#ac69f833a9d8a77c9c32188a952dee0ba">rtp_session_get_send_ssrc</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a4cdd625ca5144d7154623afc2ceb54e2">rtp_session_get_recv_ssrc</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a90bf64fecadeb51c563e72086a99983d">rtp_session_set_seq_number</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint16_t seq)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a378d7d93a5f040b930f13bfee31ca738">rtp_session_get_seq_number</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a10d01affd5cf05cad7fef78fbdb5c8ab">rtp_session_get_rcv_ext_seq_number</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48e1e6215dae6deb8ae8d03863103a05"></a><!-- doxytag: member="rtpsession.h::rtp_session_enable_jitter_buffer" ref="a48e1e6215dae6deb8ae8d03863103a05" args="(RtpSession *session, bool_t enabled)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_enable_jitter_buffer</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, bool_t enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae414ab47e66adb8f31b7bafd58301995"></a><!-- doxytag: member="rtpsession.h::rtp_session_jitter_buffer_enabled" ref="ae414ab47e66adb8f31b7bafd58301995" args="(const RtpSession *session)" -->
ORTP_PUBLIC bool_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_jitter_buffer_enabled</b> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ed86201df2dab73c4899114adb6fc22"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_jitter_buffer_params" ref="a6ed86201df2dab73c4899114adb6fc22" args="(RtpSession *session, const JBParameters *par)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_set_jitter_buffer_params</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const <a class="el" href="struct__JBParameters.html">JBParameters</a> *par)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae773100f397659344978313bbe9c29ab"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_jitter_buffer_params" ref="ae773100f397659344978313bbe9c29ab" args="(RtpSession *session, JBParameters *par)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_get_jitter_buffer_params</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, <a class="el" href="struct__JBParameters.html">JBParameters</a> *par)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a990e62b80fd6119bcf70291ffab34f52">rtp_session_set_jitter_compensation</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int milisec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ebd90a787fa33ddd08300f0cb2327d3"></a><!-- doxytag: member="rtpsession.h::rtp_session_enable_adaptive_jitter_compensation" ref="a7ebd90a787fa33ddd08300f0cb2327d3" args="(RtpSession *session, bool_t val)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_enable_adaptive_jitter_compensation</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, bool_t val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94ae21fe6da003617a874a59b28cf7f3"></a><!-- doxytag: member="rtpsession.h::rtp_session_adaptive_jitter_compensation_enabled" ref="a94ae21fe6da003617a874a59b28cf7f3" args="(RtpSession *session)" -->
ORTP_PUBLIC bool_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_adaptive_jitter_compensation_enabled</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#ad40bebc95da58087ded9a332b91a8138">rtp_session_set_time_jump_limit</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int miliseconds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aaa16f7930be8dbc83f34052dc6dcf5ea">rtp_session_set_local_addr</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const char *addr, int rtp_port, int rtcp_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aed0d7e48b2b9ed92976800c185dbe344">rtp_session_get_local_port</a> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a064e7d14c37152d9d164050ae2792cdd">rtp_session_set_remote_addr_full</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const char *rtp_addr, int rtp_port, const char *rtcp_addr, int rtcp_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a327a9a87d3b0dc2026b7601e072c5c85"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_remote_addr_and_port" ref="a327a9a87d3b0dc2026b7601e072c5c85" args="(RtpSession *session, const char *addr, int rtp_port, int rtcp_port)" -->
ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_set_remote_addr_and_port</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const char *addr, int rtp_port, int rtcp_port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aaeef1eec87c3fd8be6d9c4c7bc4f15a9">rtp_session_set_remote_addr</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const char *addr, int port)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80648068413183930315ed72b6053cb4"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_sockets" ref="a80648068413183930315ed72b6053cb4" args="(RtpSession *session, int rtpfd, int rtcpfd)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_set_sockets</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int rtpfd, int rtcpfd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5010e027bfbd296436c193e90be0e3d7"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_transports" ref="a5010e027bfbd296436c193e90be0e3d7" args="(RtpSession *session, RtpTransport *rtptr, RtpTransport *rtcptr)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_set_transports</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, <a class="el" href="struct__RtpTransport.html">RtpTransport</a> *rtptr, <a class="el" href="struct__RtpTransport.html">RtpTransport</a> *rtcptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfbe06e15716e8a254b2ec5130f57bef"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_rtp_socket" ref="acfbe06e15716e8a254b2ec5130f57bef" args="(const RtpSession *session)" -->
ORTP_PUBLIC ortp_socket_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_get_rtp_socket</b> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64471f3fb707f3c79b90ed2c05ecd496"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_rtcp_socket" ref="a64471f3fb707f3c79b90ed2c05ecd496" args="(const RtpSession *session)" -->
ORTP_PUBLIC ortp_socket_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_get_rtcp_socket</b> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#ad35337bc752a546afa71ba990decf3d7">rtp_session_set_dscp</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int dscp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#adb7d0ad3d8aa6d2ab3fcd0583b2a2f58">rtp_session_get_dscp</a> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a2c92151be891277980b53310d49c6e8a">rtp_session_set_pktinfo</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int activate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a462f941acaf46da62312dc72d87f37e0">rtp_session_set_multicast_ttl</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int ttl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aa36dcc43bd9829403312b8fa1678cdbe">rtp_session_get_multicast_ttl</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a2b151141eca52102ae789d73a2f69aa8">rtp_session_set_multicast_loopback</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int yesno)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aefd1ecc79bb15527d8beca492a7fc6ff">rtp_session_get_multicast_loopback</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#adabb5d728c3478c3098c5b512ddf4020">rtp_session_set_send_payload_type</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int paytype)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#af0f2c6a506cef5e858e841106608f83c">rtp_session_get_send_payload_type</a> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a47123de58b2b35f3062a81a3ad3c2096">rtp_session_get_recv_payload_type</a> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a68f490b2b0d164726ae63c8aed5a0fdb">rtp_session_set_recv_payload_type</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int pt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aca69cf7c42bc5153dd295879f06ecd1d">rtp_session_set_payload_type</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int pt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a47a76ec033519c67ec320731767e603b">rtp_session_set_symmetric_rtp</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, bool_t yesno)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a84cdf75e48fea6e42b67da998e67fbda">rtp_session_set_connected_mode</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, bool_t yesno)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a51f81f1cc372d28d6c0cae4dfad8abb4">rtp_session_enable_rtcp</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, bool_t yesno)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a18f8fd0c642c60ee46a2ca347e38eef8">rtp_session_set_rtcp_report_interval</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int value_ms)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a2fa7f57751e0859cbfcec7c9e2ce370a">rtp_session_set_ssrc_changed_threshold</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int numpackets)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a84d8a1b1b9fec2d9313102763b2b9189">rtp_session_recvm_with_ts</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint32_t user_ts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a9b3315b589ad096d9d992e43c683e5af">rtp_session_create_packet</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int header_size, const uint8_t *payload, int payload_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aa8b19c40a6ee7c7965207cb08b30c1f4">rtp_session_create_packet_with_data</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint8_t *payload, int payload_size, void(*freefn)(void *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#ab18f5d4e718181d0aec97cb911a46452">rtp_session_create_packet_in_place</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint8_t *buffer, int size, void(*freefn)(void *))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a16278e8430ffb4a02be5abf2c503c21b">rtp_session_sendm_with_ts</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, <a class="el" href="structmsgb.html">mblk_t</a> *mp, uint32_t userts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#ab5f6ed8f94aa5905c9d39d72cd237d1c">rtp_session_recv_with_ts</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint8_t *buffer, int len, uint32_t ts, int *have_more)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aa16de3b4c469e6009c9aceb56ab57be3">rtp_session_send_with_ts</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const uint8_t *buffer, int len, uint32_t userts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a90798bbb8193554745764d6358d92eb6">rtp_session_register_event_queue</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, <a class="el" href="structOrtpEvQueue.html">OrtpEvQueue</a> *q)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a178f60b9a3ed018181b98b2b3c23511d"></a><!-- doxytag: member="rtpsession.h::rtp_session_unregister_event_queue" ref="a178f60b9a3ed018181b98b2b3c23511d" args="(RtpSession *session, OrtpEvQueue *q)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_unregister_event_queue</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, <a class="el" href="structOrtpEvQueue.html">OrtpEvQueue</a> *q)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87c4c86ca1edbaffd0bff28eb6d6f929"></a><!-- doxytag: member="rtpsession.h::rtp_session_compute_send_bandwidth" ref="a87c4c86ca1edbaffd0bff28eb6d6f929" args="(RtpSession *session)" -->
ORTP_PUBLIC float&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_compute_send_bandwidth</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8d75444d13f711f282f14c6fd2d165e"></a><!-- doxytag: member="rtpsession.h::rtp_session_compute_recv_bandwidth" ref="ad8d75444d13f711f282f14c6fd2d165e" args="(RtpSession *session)" -->
ORTP_PUBLIC float&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_compute_recv_bandwidth</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec4417189a4431db36b165f5ec37ab6d"></a><!-- doxytag: member="rtpsession.h::rtp_session_send_rtcp_APP" ref="aec4417189a4431db36b165f5ec37ab6d" args="(RtpSession *session, uint8_t subtype, const char *name, const uint8_t *data, int datalen)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_send_rtcp_APP</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint8_t subtype, const char *name, const uint8_t *data, int datalen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a3f517f3d2b842edf3959f22d47829e04">rtp_session_get_current_send_ts</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a48b3d8952fb6c7e4ab8c2cd11f40a957">rtp_session_get_current_recv_ts</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a99c039017b50f9379ade9fae8eaecf54">rtp_session_flush_sockets</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a27b70058f3be42c69396347514cea291">rtp_session_release_sockets</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aaaff6386c73dcf4a6d90c882969bf37b">rtp_session_resync</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a61364fca805247e3f3dde818814d4840">rtp_session_reset</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a532a998787fcb4619eb89864dc25d138">rtp_session_destroy</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC const <a class="el" href="structrtp__stats.html">rtp_stats_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a39a96475db45af2dc8d6b9918e31e24f">rtp_session_get_stats</a> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC const <a class="el" href="structjitter__stats.html">jitter_stats_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#ae038eba0453f1c9a4f3e9c41642bec3a">rtp_session_get_jitter_stats</a> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a662dacc709ae6f53ca7a6c0aaa94196f"></a><!-- doxytag: member="rtpsession.h::rtp_session_reset_stats" ref="a662dacc709ae6f53ca7a6c0aaa94196f" args="(RtpSession *session)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_reset_stats</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#af1d5a1a5b79c9c0ae7a828c9b16c8ce5">rtp_session_set_data</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#ab6e3d2ac5a51d3b1e95e66b528d959b5">rtp_session_get_data</a> (const <a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#af8fc1f8c838574f24eac9c51c6048736">rtp_session_set_recv_buf_size</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int bufsize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a3f1f1017609eb9df8fc538e4fd2cf58a">rtp_session_set_rtp_socket_send_buffer_size</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, unsigned int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a5ffc0a3552a16ead189483ab4cbd60a2">rtp_session_set_rtp_socket_recv_buffer_size</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, unsigned int size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7313c8d8e1e905e1895537da06687957"></a><!-- doxytag: member="rtpsession.h::rtp_session_ts_to_time" ref="a7313c8d8e1e905e1895537da06687957" args="(RtpSession *session, uint32_t timestamp)" -->
ORTP_PUBLIC uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_ts_to_time</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint32_t timestamp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79a9ee1d1b680c9c9530ddbf61b64828"></a><!-- doxytag: member="rtpsession.h::rtp_session_time_to_ts" ref="a79a9ee1d1b680c9c9530ddbf61b64828" args="(RtpSession *session, int millisecs)" -->
ORTP_PUBLIC uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_time_to_ts</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int millisecs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a090d01342ace03135530f93521f7b489"></a><!-- doxytag: member="rtpsession.h::rtp_session_make_time_distorsion" ref="a090d01342ace03135530f93521f7b489" args="(RtpSession *session, int milisec)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_make_time_distorsion</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int milisec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#afd5a1c208cbffa18479e7d97400e5264">rtp_session_set_source_description</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const char *cname, const char *name, const char *email, const char *phone, const char *loc, const char *tool, const char *note)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cc66c705f0146beb34109f3dd7aeb21"></a><!-- doxytag: member="rtpsession.h::rtp_session_add_contributing_source" ref="a2cc66c705f0146beb34109f3dd7aeb21" args="(RtpSession *session, uint32_t csrc, const char *cname, const char *name, const char *email, const char *phone, const char *loc, const char *tool, const char *note)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_add_contributing_source</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint32_t csrc, const char *cname, const char *name, const char *email, const char *phone, const char *loc, const char *tool, const char *note)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31e91cf05387069d93bbd29ef83d2e60"></a><!-- doxytag: member="rtpsession.h::rtp_session_remove_contributing_sources" ref="a31e91cf05387069d93bbd29ef83d2e60" args="(RtpSession *session, uint32_t csrc)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_remove_contributing_sources</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, uint32_t csrc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae84f7b74c8069ad1f9cffbfe421bba13"></a><!-- doxytag: member="rtpsession.h::rtp_session_create_rtcp_sdes_packet" ref="ae84f7b74c8069ad1f9cffbfe421bba13" args="(RtpSession *session)" -->
ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_create_rtcp_sdes_packet</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a5b5bd846b3b688a9045d5ea5811bc49a">rtp_session_get_last_recv_time</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, struct timeval *tv)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aedcd90f02086ee46cec7a3236109c967">rtp_session_bye</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const char *reason)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeef81c4ec25786ea835b9c95af4728b"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_last_send_error_code" ref="aeeef81c4ec25786ea835b9c95af4728b" args="(RtpSession *session)" -->
ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_get_last_send_error_code</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a265f127feb706b46e9db49bf7830c2e2"></a><!-- doxytag: member="rtpsession.h::rtp_session_clear_send_error_code" ref="a265f127feb706b46e9db49bf7830c2e2" args="(RtpSession *session)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_clear_send_error_code</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addce1374bfbf95e8c603e22104bc3442"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_last_recv_error_code" ref="addce1374bfbf95e8c603e22104bc3442" args="(RtpSession *session)" -->
ORTP_PUBLIC int&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_get_last_recv_error_code</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4542f91f231aee1dcb4a02e0b9fc462a"></a><!-- doxytag: member="rtpsession.h::rtp_session_clear_recv_error_code" ref="a4542f91f231aee1dcb4a02e0b9fc462a" args="(RtpSession *session)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_clear_recv_error_code</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#ad5b6f1e9d6b88465f9e25ae22dd8b990">rtp_session_get_round_trip_propagation</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d9570f6aa9cb04dddc2ddcafca633dd"></a><!-- doxytag: member="rtpsession.h::rtp_session_enable_network_simulation" ref="a1d9570f6aa9cb04dddc2ddcafca633dd" args="(RtpSession *session, const OrtpNetworkSimulatorParams *params)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_enable_network_simulation</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const <a class="el" href="struct__OrtpNetworkSimulatorParams.html">OrtpNetworkSimulatorParams</a> *params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#ae237369a1525dfb6a854e14e421491ae">rtp_session_rtcp_set_lost_packet_value</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const unsigned int value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For <b>test purpose only</b>, sets a constant lost packet value within <b>all</b> RTCP output packets.<br/>
.  <a href="#ae237369a1525dfb6a854e14e421491ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a057da1f0ee359794c914c16584dcf909">rtp_session_rtcp_set_jitter_value</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const unsigned int value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For <b>test purpose only</b>, sets a constant interarrival_jitter value within <b>all</b> RTCP output packets.<br/>
.  <a href="#a057da1f0ee359794c914c16584dcf909"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#a6d4ba8e67b2d5a802f839162408acb44">rtp_session_rtcp_set_delay_value</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const unsigned int value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For <b>test purpose only</b>, simulates a constant RTT (Round Trip Time) value by setting the LSR field within <b>all</b> returned RTCP output packets.<br/>
.  <a href="#a6d4ba8e67b2d5a802f839162408acb44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtpsession_8h.html#aa1c5b262e36a06fcab1c96c409b75ee0">rtp_session_pick_with_cseq</a> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, const uint16_t sequence_number)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abed2e96e0e3056ac196ca4b5115c2a78"></a><!-- doxytag: member="rtpsession.h::rtp_session_init" ref="abed2e96e0e3056ac196ca4b5115c2a78" args="(RtpSession *session, int mode)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_init</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, int mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f5ac9470cf762b4d6ef6552255b89db"></a><!-- doxytag: member="rtpsession.h::rtp_session_uninit" ref="a5f5ac9470cf762b4d6ef6552255b89db" args="(RtpSession *session)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_uninit</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47bb9ea5dbab5b73ca3e270cf9d01695"></a><!-- doxytag: member="rtpsession.h::rtp_session_dispatch_event" ref="a47bb9ea5dbab5b73ca3e270cf9d01695" args="(RtpSession *session, OrtpEvent *ev)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_dispatch_event</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, <a class="el" href="structmsgb.html">OrtpEvent</a> *ev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c9007b57bb279762cfda2d64a75aaea"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_reuseaddr" ref="a4c9007b57bb279762cfda2d64a75aaea" args="(RtpSession *session, bool_t yes)" -->
ORTP_PUBLIC void&nbsp;</td><td class="memItemRight" valign="bottom"><b>rtp_session_set_reuseaddr</b> (<a class="el" href="struct__RtpSession.html">RtpSession</a> *session, bool_t yes)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The RtpSession api. </p>
<p>The RtpSession objects represent a RTP session: once it is configured with local and remote network addresses and a payload type is given, it let you send and recv a media stream. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a045ce176ebe9323b1e7574e35c5fc777"></a><!-- doxytag: member="rtpsession.h::JBParameters" ref="a045ce176ebe9323b1e7574e35c5fc777" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__JBParameters.html">_JBParameters</a>  <a class="el" href="struct__JBParameters.html">JBParameters</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Jitter buffer parameters </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aedcd90f02086ee46cec7a3236109c967"></a><!-- doxytag: member="rtpsession.h::rtp_session_bye" ref="aedcd90f02086ee46cec7a3236109c967" args="(RtpSession *session, const char *reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_bye </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a RTCP bye packet. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>RtpSession </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>the reason phrase. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b3315b589ad096d9d992e43c683e5af"></a><!-- doxytag: member="rtpsession.h::rtp_session_create_packet" ref="a9b3315b589ad096d9d992e43c683e5af" args="(RtpSession *session, int header_size, const uint8_t *payload, int payload_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a>* rtp_session_create_packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>header_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>payload_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a new rtp packet. In the header, ssrc and payload_type according to the session's context. Timestamp is not set, it will be set when the packet is going to be sent with <a class="el" href="rtpsession_8h.html#a16278e8430ffb4a02be5abf2c503c21b">rtp_session_sendm_with_ts()</a>. Sequence number is initalized to previous sequence number sent + 1 If payload_size is zero, thus an empty packet (just a RTP header) is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>header_size</em>&nbsp;</td><td>the rtp header size. For standart size (without extensions), it is RTP_FIXED_HEADER_SIZE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>data to be copied into the rtp packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_size</em>&nbsp;</td><td>size of data carried by the rtp packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a rtp packet in a mblk_t (message block) structure. </dd></dl>

</div>
</div>
<a class="anchor" id="ab18f5d4e718181d0aec97cb911a46452"></a><!-- doxytag: member="rtpsession.h::rtp_session_create_packet_in_place" ref="ab18f5d4e718181d0aec97cb911a46452" args="(RtpSession *session, uint8_t *buffer, int size, void(*freefn)(void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a>* rtp_session_create_packet_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>freefn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new rtp packet using the buffer given in arguments (no copy). In the header, ssrc and payload_type according to the session's context. Timestamp and seq number are not set, there will be set when the packet is going to be sent with <a class="el" href="rtpsession_8h.html#a16278e8430ffb4a02be5abf2c503c21b">rtp_session_sendm_with_ts()</a>.  can be NULL, in that case payload will be kept untouched.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>a buffer that contains first just enough place to write a RTP header, then the data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freefn</em>&nbsp;</td><td>a function that will be called once the buffer is no more needed (the data has been sent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a rtp packet in a mblk_t (message block) structure. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8b19c40a6ee7c7965207cb08b30c1f4"></a><!-- doxytag: member="rtpsession.h::rtp_session_create_packet_with_data" ref="aa8b19c40a6ee7c7965207cb08b30c1f4" args="(RtpSession *session, uint8_t *payload, int payload_size, void(*freefn)(void *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a>* rtp_session_create_packet_with_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>freefn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new rtp packet using the given payload buffer (no copy). The header will be allocated separetely. In the header, ssrc and payload_type according to the session's context. Timestamp and seq number are not set, there will be set when the packet is going to be sent with <a class="el" href="rtpsession_8h.html#a16278e8430ffb4a02be5abf2c503c21b">rtp_session_sendm_with_ts()</a>. oRTP will send this packet using libc's sendmsg() (if this function is availlable!) so that there will be no packet concatenation involving copies to be done in user-space.  can be NULL, in that case payload will be kept untouched.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>the data to be sent with this packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_size</em>&nbsp;</td><td>size of data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freefn</em>&nbsp;</td><td>a function that will be called when the payload buffer is no more needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: a rtp packet in a mblk_t (message block) structure. </dd></dl>

</div>
</div>
<a class="anchor" id="a532a998787fcb4619eb89864dc25d138"></a><!-- doxytag: member="rtpsession.h::rtp_session_destroy" ref="a532a998787fcb4619eb89864dc25d138" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroys a rtp session. All memory allocated for the RtpSession is freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51f81f1cc372d28d6c0cae4dfad8abb4"></a><!-- doxytag: member="rtpsession.h::rtp_session_enable_rtcp" ref="a51f81f1cc372d28d6c0cae4dfad8abb4" args="(RtpSession *session, bool_t yesno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_enable_rtcp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool_t&nbsp;</td>
          <td class="paramname"> <em>yesno</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>By default oRTP automatically sends RTCP SR or RR packets. If yesno is set to FALSE, the RTCP sending of packet is disabled. This functionnality might be needed for some equipments that do not support RTCP, leading to a traffic of ICMP errors on the network. It can also be used to save bandwidth despite the RTCP bandwidth is actually and usually very very low. </p>

</div>
</div>
<a class="anchor" id="a99c039017b50f9379ade9fae8eaecf54"></a><!-- doxytag: member="rtpsession.h::rtp_session_flush_sockets" ref="a99c039017b50f9379ade9fae8eaecf54" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_flush_sockets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_flush_sockets: : a rtp session</p>
<p>Flushes the sockets for all pending incoming packets. This can be usefull if you did not listen to the stream for a while and wishes to start to receive again. During the time no receive is made packets get bufferised into the internal kernel socket structure. </p>

</div>
</div>
<a class="anchor" id="a48b3d8952fb6c7e4ab8c2cd11f40a957"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_current_recv_ts" ref="a48b3d8952fb6c7e4ab8c2cd11f40a957" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC uint32_t rtp_session_get_current_recv_ts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same thing as <a class="el" href="rtpsession_8h.html#a3f517f3d2b842edf3959f22d47829e04">rtp_session_get_current_send_ts()</a> except that it's for an incoming stream. Works only on scheduled mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the theoritical that would have to be receive now. </dd></dl>

<p>References <a class="el" href="payloadtype_8h_source.html#l00056">_PayloadType::clock_rate</a>.</p>

</div>
</div>
<a class="anchor" id="a3f517f3d2b842edf3959f22d47829e04"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_current_send_ts" ref="a3f517f3d2b842edf3959f22d47829e04" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC uint32_t rtp_session_get_current_send_ts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When the rtp session is scheduled and has started to send packets, this function computes the timestamp that matches to the present time. Using this function can be usefull when sending discontinuous streams. Some time can be elapsed between the end of a stream burst and the begin of a new stream burst, and the application may be not not aware of this elapsed time. In order to get a valid (current) timestamp to pass to <a class="el" href="rtpsession_8h.html#aa16de3b4c469e6009c9aceb56ab57be3">rtp_session_send_with_ts()</a> or <a class="el" href="rtpsession_8h.html#a16278e8430ffb4a02be5abf2c503c21b">rtp_session_sendm_with_ts()</a>, the application may use <a class="el" href="rtpsession_8h.html#a3f517f3d2b842edf3959f22d47829e04">rtp_session_get_current_send_ts()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the current send timestamp for the rtp session. </dd></dl>

<p>References <a class="el" href="payloadtype_8h_source.html#l00056">_PayloadType::clock_rate</a>.</p>

</div>
</div>
<a class="anchor" id="ab6e3d2ac5a51d3b1e95e66b528d959b5"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_data" ref="ab6e3d2ac5a51d3b1e95e66b528d959b5" args="(const RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void* rtp_session_get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the void pointer previously set using <a class="el" href="rtpsession_8h.html#af1d5a1a5b79c9c0ae7a828c9b16c8ce5">rtp_session_set_data()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adb7d0ad3d8aa6d2ab3fcd0583b2a2f58"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_dscp" ref="adb7d0ad3d8aa6d2ab3fcd0583b2a2f58" args="(const RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_get_dscp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_get_dscp: : a rtp session</p>
<p>Returns the DSCP (Differentiated Services Code Point) for outgoing RTP packets. </p>

</div>
</div>
<a class="anchor" id="ae038eba0453f1c9a4f3e9c41642bec3a"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_jitter_stats" ref="ae038eba0453f1c9a4f3e9c41642bec3a" args="(const RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC const <a class="el" href="structjitter__stats.html">jitter_stats_t</a>* rtp_session_get_jitter_stats </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the session's jitter specific statistics. </p>

</div>
</div>
<a class="anchor" id="a5b5bd846b3b688a9045d5ea5811bc49a"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_last_recv_time" ref="a5b5bd846b3b688a9045d5ea5811bc49a" args="(RtpSession *session, struct timeval *tv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_get_last_recv_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timeval *&nbsp;</td>
          <td class="paramname"> <em>tv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets last time a valid RTP or RTCP packet was received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>RtpSession to get last receive time from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tv</em>&nbsp;</td><td>Pointer to struct timeval to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed0d7e48b2b9ed92976800c185dbe344"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_local_port" ref="aed0d7e48b2b9ed92976800c185dbe344" args="(const RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_get_local_port </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_get_local_port: : a rtp session for which <a class="el" href="rtpsession_8h.html#aaa16f7930be8dbc83f34052dc6dcf5ea">rtp_session_set_local_addr()</a> or <a class="el" href="rtpsession_8h.html#aaeef1eec87c3fd8be6d9c4c7bc4f15a9">rtp_session_set_remote_addr()</a> has been called</p>
<p>This function can be useful to retrieve the local port that was randomly choosen by <a class="el" href="rtpsession_8h.html#aaeef1eec87c3fd8be6d9c4c7bc4f15a9">rtp_session_set_remote_addr()</a> when <a class="el" href="rtpsession_8h.html#aaa16f7930be8dbc83f34052dc6dcf5ea">rtp_session_set_local_addr()</a> was not called.</p>
<p>Returns: the local port used to listen for rtp packets, -1 if not set. </p>

</div>
</div>
<a class="anchor" id="aefd1ecc79bb15527d8beca492a7fc6ff"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_multicast_loopback" ref="aefd1ecc79bb15527d8beca492a7fc6ff" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_get_multicast_loopback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_get_multicast_loopback: : a rtp session</p>
<p>Returns the multicast loopback state of rtp session (true or false). </p>

</div>
</div>
<a class="anchor" id="aa36dcc43bd9829403312b8fa1678cdbe"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_multicast_ttl" ref="aa36dcc43bd9829403312b8fa1678cdbe" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_get_multicast_ttl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_get_multicast_ttl: : a rtp session</p>
<p>Returns the TTL (Time-To-Live) for outgoing multicast packets. </p>

</div>
</div>
<a class="anchor" id="a1b34ab1de41bb00744e8406c0fa8a924"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_profile" ref="a1b34ab1de41bb00744e8406c0fa8a924" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC <a class="el" href="struct__RtpProfile.html">RtpProfile</a>* rtp_session_get_profile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session</td></tr>
  </table>
  </dd>
</dl>
<p>DEPRECATED! Returns current send profile. Use <a class="el" href="rtpsession_8h.html#acf5fabd53db6e9894893968609397f0a">rtp_session_get_send_profile()</a> or <a class="el" href="rtpsession_8h.html#a3593bfda1342853369bba062507fa7be">rtp_session_get_recv_profile()</a> </p>

</div>
</div>
<a class="anchor" id="a10d01affd5cf05cad7fef78fbdb5c8ab"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_rcv_ext_seq_number" ref="a10d01affd5cf05cad7fef78fbdb5c8ab" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC uint32_t rtp_session_get_rcv_ext_seq_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the highest extended sequence number received. </p>

</div>
</div>
<a class="anchor" id="a47123de58b2b35f3062a81a3ad3c2096"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_recv_payload_type" ref="a47123de58b2b35f3062a81a3ad3c2096" args="(const RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_get_recv_payload_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the payload type currently used in incoming rtp packets </dd></dl>

</div>
</div>
<a class="anchor" id="a3593bfda1342853369bba062507fa7be"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_recv_profile" ref="a3593bfda1342853369bba062507fa7be" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC <a class="el" href="struct__RtpProfile.html">RtpProfile</a>* rtp_session_get_recv_profile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session</td></tr>
  </table>
  </dd>
</dl>
<p>Returns current receive profile. </p>

</div>
</div>
<a class="anchor" id="a4cdd625ca5144d7154623afc2ceb54e2"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_recv_ssrc" ref="a4cdd625ca5144d7154623afc2ceb54e2" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC uint32_t rtp_session_get_recv_ssrc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the SSRC for the incoming stream.</p>
<p>If no packets have been received yet, 0 is returned. </p>

</div>
</div>
<a class="anchor" id="ad5b6f1e9d6b88465f9e25ae22dd8b990"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_round_trip_propagation" ref="ad5b6f1e9d6b88465f9e25ae22dd8b990" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC float rtp_session_get_round_trip_propagation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the last known round trip propagation delay.</p>
<p>This value is known after successful RTCP SR or RR exchanged between a sender and a receiver. oRTP automatically takes care of sending SR or RR packets. You might want to call this function when you receive an RTCP event (see <a class="el" href="rtpsession_8h.html#a90798bbb8193554745764d6358d92eb6">rtp_session_register_event_queue()</a> ). This value might not be known: at the beginning when no RTCP packets have been exchanged yet, or simply because the rtcp channel is broken due to firewall problematics, or because the remote implementation does not support RTCP.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the round trip propagation time in seconds if known, -1 if unknown. </dd></dl>

</div>
</div>
<a class="anchor" id="af0f2c6a506cef5e858e841106608f83c"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_send_payload_type" ref="af0f2c6a506cef5e858e841106608f83c" args="(const RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_get_send_payload_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the payload type currently used in outgoing rtp packets </dd></dl>

</div>
</div>
<a class="anchor" id="acf5fabd53db6e9894893968609397f0a"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_send_profile" ref="acf5fabd53db6e9894893968609397f0a" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC <a class="el" href="struct__RtpProfile.html">RtpProfile</a>* rtp_session_get_send_profile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session</td></tr>
  </table>
  </dd>
</dl>
<p>Returns current send profile. </p>

</div>
</div>
<a class="anchor" id="ac69f833a9d8a77c9c32188a952dee0ba"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_send_ssrc" ref="ac69f833a9d8a77c9c32188a952dee0ba" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC uint32_t rtp_session_get_send_ssrc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the SSRC for the outgoing stream.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a378d7d93a5f040b930f13bfee31ca738"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_seq_number" ref="a378d7d93a5f040b930f13bfee31ca738" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC uint16_t rtp_session_get_seq_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current sequence number for outgoing stream. </p>

</div>
</div>
<a class="anchor" id="a39a96475db45af2dc8d6b9918e31e24f"></a><!-- doxytag: member="rtpsession.h::rtp_session_get_stats" ref="a39a96475db45af2dc8d6b9918e31e24f" args="(const RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC const <a class="el" href="structrtp__stats.html">rtp_stats_t</a>* rtp_session_get_stats </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the session's statistics. </p>

</div>
</div>
<a class="anchor" id="a669759d404518c7d77e86fe968f8055c"></a><!-- doxytag: member="rtpsession.h::rtp_session_new" ref="a669759d404518c7d77e86fe968f8055c" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC <a class="el" href="struct__RtpSession.html">RtpSession</a>* rtp_session_new </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new rtp session. If the session is able to send data (RTP_SESSION_SENDONLY or RTP_SESSION_SENDRECV), then a random SSRC number is choosed for the outgoing stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>One of the RtpSessionMode flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the newly created rtp session. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1c5b262e36a06fcab1c96c409b75ee0"></a><!-- doxytag: member="rtpsession.h::rtp_session_pick_with_cseq" ref="aa1c5b262e36a06fcab1c96c409b75ee0" args="(RtpSession *session, const uint16_t sequence_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a>* rtp_session_pick_with_cseq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>sequence_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Try to get an rtp packet presented as a mblk_t structure from the rtp session at a given sequence number. This function is very usefull for codec with Forward error correction capabilities</p>
<p>This function returns the entire packet (with header).</p>
<p>* </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sequence_number</em>&nbsp;</td><td>a sequence number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a rtp packet presented as a mblk_t, or NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5f6ed8f94aa5905c9d39d72cd237d1c"></a><!-- doxytag: member="rtpsession.h::rtp_session_recv_with_ts" ref="ab5f6ed8f94aa5905c9d39d72cd237d1c" args="(RtpSession *session, uint8_t *buffer, int len, uint32_t ts, int *have_more)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_recv_with_ts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>ts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>have_more</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>NOTE: use of this function is discouraged when sending payloads other than pcm/pcmu/pcma/adpcm types. <a class="el" href="rtpsession_8h.html#a84d8a1b1b9fec2d9313102763b2b9189">rtp_session_recvm_with_ts()</a> does better job.</p>
<p>Tries to read the bytes of the incoming rtp stream related to timestamp ts. In case where the user supplied buffer  is not large enough to get all the data related to timestamp ts, then *( have_more) is set to 1 to indicate that the application should recall the function with the same timestamp to get more data.</p>
<p>When the rtp session is scheduled (see <a class="el" href="rtpsession_8h.html#a3204997f541c6f5a899da18029493ef8">rtp_session_set_scheduling_mode()</a> ), and the blocking mode is on (see <a class="el" href="rtpsession_8h.html#a8887542ffcaaafdb6ae7157f267a6aca">rtp_session_set_blocking_mode()</a> ), then the calling thread is suspended until the timestamp given as argument expires, whatever a received packet fits the query or not.</p>
<p>Important note: it is clear that the application cannot know the timestamp of the first packet of the incoming stream, because it can be random. The  timestamp given to the function is used relatively to first timestamp of the stream. In simple words, 0 is a good value to start calling this function.</p>
<p>This function internally calls <a class="el" href="rtpsession_8h.html#a84d8a1b1b9fec2d9313102763b2b9189">rtp_session_recvm_with_ts()</a> to get a rtp packet. The content of this packet is then copied into the user supplied buffer in an intelligent manner: the function takes care of the size of the supplied buffer and the timestamp given in argument. Using this function it is possible to read continous audio data (e.g. pcma,pcmu...) with for example a standart buffer of size of 160 with timestamp incrementing by 160 while the incoming stream has a different packet size.</p>
<p>Returns: if a packet was availlable with the corresponding timestamp supplied in argument then the number of bytes written in the user supplied buffer is returned. If no packets are availlable, either because the sender has not started to send the stream, or either because silence packet are not transmitted, or either because the packet was lost during network transport, then the function returns zero. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>a user supplied buffer to write the data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the length in bytes of the user supplied buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ts</em>&nbsp;</td><td>the timestamp wanted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>have_more</em>&nbsp;</td><td>the address of an integer to indicate if more data is availlable for the given timestamp. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84d8a1b1b9fec2d9313102763b2b9189"></a><!-- doxytag: member="rtpsession.h::rtp_session_recvm_with_ts" ref="a84d8a1b1b9fec2d9313102763b2b9189" args="(RtpSession *session, uint32_t user_ts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC <a class="el" href="structmsgb.html">mblk_t</a>* rtp_session_recvm_with_ts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>user_ts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Try to get a rtp packet presented as a mblk_t structure from the rtp session. The  parameter is relative to the first timestamp of the incoming stream. In other words, the application does not have to know the first timestamp of the stream, it can simply call for the first time this function with =0, and then incrementing it as it want. The RtpSession takes care of synchronisation between the stream timestamp and the user timestamp given here.</p>
<p>This function returns the entire packet (with header).</p>
<p>The behaviour of this function has changed since version 0.15.0. Previously the payload data could be accessed using mblk_t::b_cont::b_rptr field of the returned mblk_t. This is no more the case. The convenient way of accessing the payload data is to use rtp_get_payload() : </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *payload;
        <span class="keywordtype">int</span> payload_size;
        payload_size=rtp_get_payload(mp,&amp;payload);
</pre></div><p> OR simply skip the header this way, the data is then comprised between mp-&gt;b_rptr and mp-&gt;b_wptr: </p>
<div class="fragment"><pre class="fragment">        rtp_get_payload(mp,&amp;mp-&gt;b_rptr);
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_ts</em>&nbsp;</td><td>a timestamp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a rtp packet presented as a mblk_t. </dd></dl>

<p>References <a class="el" href="sessionset_8h_source.html#l00121">session_set_clr</a>, and <a class="el" href="sessionset_8h_source.html#l00104">session_set_set</a>.</p>

</div>
</div>
<a class="anchor" id="a90798bbb8193554745764d6358d92eb6"></a><!-- doxytag: member="rtpsession.h::rtp_session_register_event_queue" ref="a90798bbb8193554745764d6358d92eb6" args="(RtpSession *session, OrtpEvQueue *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_register_event_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOrtpEvQueue.html">OrtpEvQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register an event queue. An application can use an event queue to get informed about various RTP events. </p>

</div>
</div>
<a class="anchor" id="a27b70058f3be42c69396347514cea291"></a><!-- doxytag: member="rtpsession.h::rtp_session_release_sockets" ref="a27b70058f3be42c69396347514cea291" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_release_sockets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the rtp and rtcp sockets. </p>

</div>
</div>
<a class="anchor" id="a61364fca805247e3f3dde818814d4840"></a><!-- doxytag: member="rtpsession.h::rtp_session_reset" ref="a61364fca805247e3f3dde818814d4840" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the session: local and remote addresses are kept. It resets timestamp, sequence number, and calls <a class="el" href="rtpsession_8h.html#aaaff6386c73dcf4a6d90c882969bf37b">rtp_session_resync()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaff6386c73dcf4a6d90c882969bf37b"></a><!-- doxytag: member="rtpsession.h::rtp_session_resync" ref="aaaff6386c73dcf4a6d90c882969bf37b" args="(RtpSession *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_resync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resynchronize to the incoming RTP streams. This can be useful to handle discoutinuous timestamps. For example, call this function from the timestamp_jump signal handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>the rtp session </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d4ba8e67b2d5a802f839162408acb44"></a><!-- doxytag: member="rtpsession.h::rtp_session_rtcp_set_delay_value" ref="a6d4ba8e67b2d5a802f839162408acb44" args="(RtpSession *session, const unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_rtcp_set_delay_value </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct__RtpSession.html">_RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For <b>test purpose only</b>, simulates a constant RTT (Round Trip Time) value by setting the LSR field within <b>all</b> returned RTCP output packets.<br/>
. </p>
<p>The RTT processing involves two RTCP packets exchanged between two different devices.<br/>
 In a <b>normal</b> operation the device 1 issues a SR packets at time T0, hence this packet has a timestamp field set to T0. The LSR and DLSR fiels of that packet are not considered here. This packet is received by the Device 2 at T1. In response, the Device 2 issues another SR or RR packets at T2 with the following fields;</p>
<ul>
<li>a timestamp set to T2.</li>
<li>a LSR (Last SR packet timestamp) field set to T0 ( this value has been extracted from the first packet).</li>
<li>a DLSR (Delay since Last SR packet) field set to (T2 - T1).</li>
</ul>
<p>This packet is received by The Device 1 at T3. So the Device 1 is now able to process the RTT using the formula : RTT = T3 - LSR - DLSR = (T1 - T0) - (T3 - T2).<br/>
 This way of processing is described in par. 6.4 of the RFC3550 standard.</p>
<p>In the <b>test</b> mode that is enabled by this procedure, the RTCP stack is considered as beeing part of the device 2. For setting the RTT to a constant RTT0 value, the Device 2 artificially sets the LSR field of the second packet to (T1 - RTT0), instead of T0 in normal mode. The two other fields (timestamp and DLSR) are set as in the normal mode. So the Device 1 will process : RTT = T3 - LSR - DLSR = RTT0 + (T3 - T2) that is near to RTT0 is T3 - T2 is small enough. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is impossible to actually make the mesured RTT strictly equal to RTT0, as the packet trip time (T3 - T2) is unknown when this packet is issued by the Device 2. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>: the rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>: The desired RTT test vector value (RTT0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a057da1f0ee359794c914c16584dcf909"></a><!-- doxytag: member="rtpsession.h::rtp_session_rtcp_set_jitter_value" ref="a057da1f0ee359794c914c16584dcf909" args="(RtpSession *session, const unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_rtcp_set_jitter_value </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct__RtpSession.html">_RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For <b>test purpose only</b>, sets a constant interarrival_jitter value within <b>all</b> RTCP output packets.<br/>
. </p>
<p>The SR or RR RTCP packet contain an interarrival jitter field. After this procedure is called, the interarrival jitter field will be set to a constant value in all output SR or RR packets. This parameter will overridden the actual interarrival jitter value that was processed by the RTCP stack. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>: the rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>: the interarrival jitter test vector value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae237369a1525dfb6a854e14e421491ae"></a><!-- doxytag: member="rtpsession.h::rtp_session_rtcp_set_lost_packet_value" ref="ae237369a1525dfb6a854e14e421491ae" args="(RtpSession *session, const unsigned int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_rtcp_set_lost_packet_value </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct__RtpSession.html">_RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>For <b>test purpose only</b>, sets a constant lost packet value within <b>all</b> RTCP output packets.<br/>
. </p>
<p>The SR or RR RTCP packet contain a lost packet field. After this procedure is called, the lost packet field will be set to a constant value in all output SR or RR packets. This parameter will overridden the actual number of lost packets in the input RTP stream that the RTCP stack had previously processed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>: the rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>: the lost packets test vector value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa16de3b4c469e6009c9aceb56ab57be3"></a><!-- doxytag: member="rtpsession.h::rtp_session_send_with_ts" ref="aa16de3b4c469e6009c9aceb56ab57be3" args="(RtpSession *session, const uint8_t *buffer, int len, uint32_t userts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_send_with_ts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>userts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a rtp datagram to the destination set by <a class="el" href="rtpsession_8h.html#aaeef1eec87c3fd8be6d9c4c7bc4f15a9">rtp_session_set_remote_addr()</a> containing the data from  with timestamp . This is a high level function that uses <a class="el" href="rtpsession_8h.html#a9b3315b589ad096d9d992e43c683e5af">rtp_session_create_packet()</a> and <a class="el" href="rtpsession_8h.html#a16278e8430ffb4a02be5abf2c503c21b">rtp_session_sendm_with_ts()</a> to send the data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>a buffer containing the data to be sent in a rtp packet. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the length of the data buffer, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userts</em>&nbsp;</td><td>the timestamp of the data to be sent. Refer to the rfc to know what it is.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>return</em>&nbsp;</td><td>the number of bytes sent over the network. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a16278e8430ffb4a02be5abf2c503c21b"></a><!-- doxytag: member="rtpsession.h::rtp_session_sendm_with_ts" ref="a16278e8430ffb4a02be5abf2c503c21b" args="(RtpSession *session, mblk_t *mp, uint32_t userts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_sendm_with_ts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsgb.html">mblk_t</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timestamp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send the rtp datagram  to the destination set by <a class="el" href="rtpsession_8h.html#aaeef1eec87c3fd8be6d9c4c7bc4f15a9">rtp_session_set_remote_addr()</a> with timestamp . For audio data, the timestamp is the number of the first sample resulting of the data transmitted. See rfc1889 for details. The packet () is freed once it is sended.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mp</em>&nbsp;</td><td>a rtp packet presented as a mblk_t. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>the timestamp of the data to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes sent over the network. </dd></dl>

</div>
</div>
<a class="anchor" id="a8887542ffcaaafdb6ae7157f267a6aca"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_blocking_mode" ref="a8887542ffcaaafdb6ae7157f267a6aca" args="(RtpSession *session, int yesno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_blocking_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>yesno</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function implicitely enables the scheduling mode if yesno is TRUE. <a class="el" href="rtpsession_8h.html#a8887542ffcaaafdb6ae7157f267a6aca">rtp_session_set_blocking_mode()</a> defines the behaviour of the <a class="el" href="rtpsession_8h.html#ab5f6ed8f94aa5905c9d39d72cd237d1c">rtp_session_recv_with_ts()</a> and <a class="el" href="rtpsession_8h.html#aa16de3b4c469e6009c9aceb56ab57be3">rtp_session_send_with_ts()</a> functions. If  is TRUE, <a class="el" href="rtpsession_8h.html#ab5f6ed8f94aa5905c9d39d72cd237d1c">rtp_session_recv_with_ts()</a> will block until it is time for the packet to be received, according to the timestamp passed to the function. After this time, the function returns. For <a class="el" href="rtpsession_8h.html#aa16de3b4c469e6009c9aceb56ab57be3">rtp_session_send_with_ts()</a>, it will block until it is time for the packet to be sent. If  is FALSE, then the two functions will return immediately.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yesno</em>&nbsp;</td><td>a boolean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84cdf75e48fea6e42b67da998e67fbda"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_connected_mode" ref="a84cdf75e48fea6e42b67da998e67fbda" args="(RtpSession *session, bool_t yesno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_connected_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool_t&nbsp;</td>
          <td class="paramname"> <em>yesno</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If yesno is TRUE, thus a connect() syscall is done on the socket to the destination address set by <a class="el" href="rtpsession_8h.html#aaeef1eec87c3fd8be6d9c4c7bc4f15a9">rtp_session_set_remote_addr()</a>, or if the session does symmetric rtp (see <a class="el" href="rtpsession_8h.html#a47a76ec033519c67ec320731767e603b">rtp_session_set_symmetric_rtp()</a>) a the connect() is done to the source address of the first packet received. Connecting a socket has effect of rejecting all incoming packets that don't come from the address specified in connect(). It also makes ICMP errors (such as connection refused) available to the application. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yesno</em>&nbsp;</td><td>a boolean to enable or disable the feature </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1d5a1a5b79c9c0ae7a828c9b16c8ce5"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_data" ref="af1d5a1a5b79c9c0ae7a828c9b16c8ce5" args="(RtpSession *session, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores some application specific data into the session, so that it is easy to retrieve it from the signal callbacks using <a class="el" href="rtpsession_8h.html#ab6e3d2ac5a51d3b1e95e66b528d959b5">rtp_session_get_data()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>an opaque pointer to be stored in the session </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad35337bc752a546afa71ba990decf3d7"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_dscp" ref="ad35337bc752a546afa71ba990decf3d7" args="(RtpSession *session, int dscp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_dscp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dscp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_set_dscp: : a rtp session : desired DSCP PHB value</p>
<p>Sets the DSCP (Differentiated Services Code Point) for outgoing RTP packets.</p>
<p>Returns: 0 on success. </p>

</div>
</div>
<a class="anchor" id="a990e62b80fd6119bcf70291ffab34f52"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_jitter_compensation" ref="a990e62b80fd6119bcf70291ffab34f52" args="(RtpSession *session, int milisec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_jitter_compensation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>milisec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_set_jitter_compensation: : a RtpSession : the time interval in milisec to be jitter compensed.</p>
<p>Sets the time interval for which packet are buffered instead of being delivered to the application. </p>

</div>
</div>
<a class="anchor" id="aaa16f7930be8dbc83f34052dc6dcf5ea"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_local_addr" ref="aaa16f7930be8dbc83f34052dc6dcf5ea" args="(RtpSession *session, const char *addr, int rtp_port, int rtcp_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_local_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rtp_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rtcp_port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_set_local_addr: : a rtp session freshly created. : a local IP address in the xxx.xxx.xxx.xxx form. : a local port or -1 to let oRTP choose the port randomly : a local port or -1 to let oRTP choose the port randomly</p>
<p>Specify the local addr to be use to listen for rtp packets or to send rtp packet from. In case where the rtp session is send-only, then it is not required to call this function: when calling <a class="el" href="rtpsession_8h.html#aaeef1eec87c3fd8be6d9c4c7bc4f15a9">rtp_session_set_remote_addr()</a>, if no local address has been set, then the default INADRR_ANY (0.0.0.0) IP address with a random port will be used. Calling rtp_sesession_set_local_addr() is mandatory when the session is recv-only or duplex.</p>
<p>Returns: 0 on success. </p>

</div>
</div>
<a class="anchor" id="a2b151141eca52102ae789d73a2f69aa8"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_multicast_loopback" ref="a2b151141eca52102ae789d73a2f69aa8" args="(RtpSession *session, int yesno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_multicast_loopback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>yesno</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_set_multicast_loopback: : a rtp session : desired Multicast Time-To-Live</p>
<p>Sets the TTL (Time-To-Live) for outgoing multicast packets.</p>
<p>Returns: 0 on success. </p>

</div>
</div>
<a class="anchor" id="a462f941acaf46da62312dc72d87f37e0"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_multicast_ttl" ref="a462f941acaf46da62312dc72d87f37e0" args="(RtpSession *session, int ttl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_multicast_ttl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ttl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_set_multicast_ttl: : a rtp session : desired Multicast Time-To-Live</p>
<p>Sets the TTL (Time-To-Live) for outgoing multicast packets.</p>
<p>Returns: 0 on success. </p>

</div>
</div>
<a class="anchor" id="aca69cf7c42bc5153dd295879f06ecd1d"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_payload_type" ref="aca69cf7c42bc5153dd295879f06ecd1d" args="(RtpSession *session, int pt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_payload_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the expected payload type for incoming packets and payload type to be used for outgoing packets. If the actual payload type in incoming packets is different that this expected payload type, thus the "payload_type_changed" signal is emitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paytype</em>&nbsp;</td><td>the payload type number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 if the payload is not defined. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c92151be891277980b53310d49c6e8a"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_pktinfo" ref="a2c92151be891277980b53310d49c6e8a" args="(RtpSession *session, int activate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_pktinfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>activate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_set_pktinfo: : a rtp session : activation flag (0 to deactivate, other value to activate)</p>
<p>(De)activates packet info for incoming and outgoing packets.</p>
<p>Returns: 0 on success. </p>

</div>
</div>
<a class="anchor" id="af3ca23d5f71565793204d6550860fecd"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_profile" ref="af3ca23d5f71565793204d6550860fecd" args="(RtpSession *session, RtpProfile *profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_profile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__RtpProfile.html">RtpProfile</a> *&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RTP profile to be used for the session. By default, all session are created by <a class="el" href="rtpsession_8h.html#a669759d404518c7d77e86fe968f8055c">rtp_session_new()</a> are initialized with the AV profile, as defined in RFC 3551. The application can set any other profile instead using that function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>a rtp profile </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8fc1f8c838574f24eac9c51c6048736"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_recv_buf_size" ref="af8fc1f8c838574f24eac9c51c6048736" args="(RtpSession *session, int bufsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_recv_buf_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>bufsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The default value is UDP_MAX_SIZE bytes, a value which is working for mostly everyone. However if your application can make assumption on the sizes of received packet, it can be interesting to set it to a lower value in order to save memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufsize</em>&nbsp;</td><td>max size in bytes for receiving packets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68f490b2b0d164726ae63c8aed5a0fdb"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_recv_payload_type" ref="a68f490b2b0d164726ae63c8aed5a0fdb" args="(RtpSession *session, int pt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_recv_payload_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>paytype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the expected payload type for incoming packets. If the actual payload type in incoming packets is different that this expected payload type, thus the "payload_type_changed" signal is emitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paytype</em>&nbsp;</td><td>the payload type number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 if the payload is not defined. </dd></dl>

</div>
</div>
<a class="anchor" id="a5afbdbcf00b48fe763fe3dfec28bbccc"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_recv_profile" ref="a5afbdbcf00b48fe763fe3dfec28bbccc" args="(RtpSession *session, RtpProfile *profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_recv_profile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__RtpProfile.html">RtpProfile</a> *&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RTP profile to be used for the receiveing by this session. By default, all session are created by <a class="el" href="rtpsession_8h.html#a669759d404518c7d77e86fe968f8055c">rtp_session_new()</a> are initialized with the AV profile, as defined in RFC 3551. The application can set any other profile instead using that function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>a rtp profile </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaeef1eec87c3fd8be6d9c4c7bc4f15a9"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_remote_addr" ref="aaeef1eec87c3fd8be6d9c4c7bc4f15a9" args="(RtpSession *session, const char *addr, int port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_remote_addr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_set_remote_addr: : a rtp session freshly created. : a local IP address in the xxx.xxx.xxx.xxx form. : a local port.</p>
<p>Sets the remote address of the rtp session, ie the destination address where rtp packet are sent. If the session is recv-only or duplex, it also sets the origin of incoming RTP packets. Rtp packets that don't come from addr:port are discarded.</p>
<p>Returns: 0 on success. </p>

</div>
</div>
<a class="anchor" id="a064e7d14c37152d9d164050ae2792cdd"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_remote_addr_full" ref="a064e7d14c37152d9d164050ae2792cdd" args="(RtpSession *session, const char *rtp_addr, int rtp_port, const char *rtcp_addr, int rtcp_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_remote_addr_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rtp_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rtp_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rtcp_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rtcp_port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>rtp_session_set_remote_addr_full: : a rtp session freshly created. : a local IP address in the xxx.xxx.xxx.xxx form. : a local rtp port. : a local IP address in the xxx.xxx.xxx.xxx form. : a local rtcp port.</p>
<p>Sets the remote address of the rtp session, ie the destination address where rtp packet are sent. If the session is recv-only or duplex, it also sets the origin of incoming RTP packets. Rtp packets that don't come from addr:port are discarded.</p>
<p>Returns: 0 on success. </p>

</div>
</div>
<a class="anchor" id="a18f8fd0c642c60ee46a2ca347e38eef8"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_rtcp_report_interval" ref="a18f8fd0c642c60ee46a2ca347e38eef8" args="(RtpSession *session, int value_ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_rtcp_report_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value_ms</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the default interval in milliseconds for RTCP reports emitted by the session </p>

<p>References <a class="el" href="payloadtype_8h_source.html#l00056">_PayloadType::clock_rate</a>.</p>

</div>
</div>
<a class="anchor" id="a5ffc0a3552a16ead189483ab4cbd60a2"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_rtp_socket_recv_buffer_size" ref="a5ffc0a3552a16ead189483ab4cbd60a2" args="(RtpSession *session, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_rtp_socket_recv_buffer_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set kernel recv maximum buffer size for the rtp socket. A value of zero defaults to the operating system default. </p>

</div>
</div>
<a class="anchor" id="a3f1f1017609eb9df8fc538e4fd2cf58a"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_rtp_socket_send_buffer_size" ref="a3f1f1017609eb9df8fc538e4fd2cf58a" args="(RtpSession *session, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_rtp_socket_send_buffer_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set kernel send maximum buffer size for the rtp socket. A value of zero defaults to the operating system default. </p>

</div>
</div>
<a class="anchor" id="a3204997f541c6f5a899da18029493ef8"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_scheduling_mode" ref="a3204997f541c6f5a899da18029493ef8" args="(RtpSession *session, int yesno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_scheduling_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>yesno</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the scheduling mode of the rtp session. If  is TRUE, the rtp session is in the scheduled mode, that means that you can use <a class="el" href="sessionset_8h.html#aff4a4bb90789ce156d321c1307b1d919">session_set_select()</a> to block until it's time to receive or send on this session according to the timestamp passed to the respective functions. You can also use blocking mode (see <a class="el" href="rtpsession_8h.html#a8887542ffcaaafdb6ae7157f267a6aca">rtp_session_set_blocking_mode()</a> ), to simply block within the receive and send functions. If  is FALSE, the ortp scheduler will not manage those sessions, meaning that blocking mode and the use of <a class="el" href="sessionset_8h.html#aff4a4bb90789ce156d321c1307b1d919">session_set_select()</a> for this session are disabled. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yesno</em>&nbsp;</td><td>a boolean to indicate the scheduling mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adabb5d728c3478c3098c5b512ddf4020"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_send_payload_type" ref="adabb5d728c3478c3098c5b512ddf4020" args="(RtpSession *session, int paytype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_set_send_payload_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>paytype</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the payload type of the rtp session. It decides of the payload types written in the of the rtp header for the outgoing stream, if the session is SENDRECV or SENDONLY. For payload type in incoming packets, the application can be informed by registering for the "payload_type_changed" signal, so that it can make the necessary changes on the downstream decoder that deals with the payload of the packets.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paytype</em>&nbsp;</td><td>the payload type number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 if the payload is not defined. </dd></dl>

</div>
</div>
<a class="anchor" id="aafa271cc4f55c2905097524e4c1c059d"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_send_profile" ref="aafa271cc4f55c2905097524e4c1c059d" args="(RtpSession *session, RtpProfile *profile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_send_profile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__RtpProfile.html">RtpProfile</a> *&nbsp;</td>
          <td class="paramname"> <em>profile</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RTP profile to be used for the sending by this session. By default, all session are created by <a class="el" href="rtpsession_8h.html#a669759d404518c7d77e86fe968f8055c">rtp_session_new()</a> are initialized with the AV profile, as defined in RFC 3551. The application can set any other profile instead using that function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>profile</em>&nbsp;</td><td>a rtp profile </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90bf64fecadeb51c563e72086a99983d"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_seq_number" ref="a90bf64fecadeb51c563e72086a99983d" args="(RtpSession *session, uint16_t seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_seq_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>seq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the initial sequence number for outgoing stream.. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session freshly created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>a 16 bit unsigned number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd5a1c208cbffa18479e7d97400e5264"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_source_description" ref="afd5a1c208cbffa18479e7d97400e5264" args="(RtpSession *session, const char *cname, const char *name, const char *email, const char *phone, const char *loc, const char *tool, const char *note)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_source_description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>cname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>email</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>note</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set session's SDES item for automatic sending of RTCP compound packets. If some items are not specified, use NULL. </p>

</div>
</div>
<a class="anchor" id="aba7a1104bd2a47faf0f7e08f084162d0"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_ssrc" ref="aba7a1104bd2a47faf0f7e08f084162d0" args="(RtpSession *session, uint32_t ssrc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_ssrc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>ssrc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the SSRC for the outgoing stream. If not done, a random ssrc is used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssrc</em>&nbsp;</td><td>an unsigned 32bit integer representing the synchronisation source identifier (SSRC). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fa7f57751e0859cbfcec7c9e2ce370a"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_ssrc_changed_threshold" ref="a2fa7f57751e0859cbfcec7c9e2ce370a" args="(RtpSession *session, int numpackets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_ssrc_changed_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numpackets</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the number of packets containg a new SSRC that will trigger the "ssrc_changed" callback. </p>

</div>
</div>
<a class="anchor" id="a47a76ec033519c67ec320731767e603b"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_symmetric_rtp" ref="a47a76ec033519c67ec320731767e603b" args="(RtpSession *session, bool_t yesno)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_symmetric_rtp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool_t&nbsp;</td>
          <td class="paramname"> <em>yesno</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable or disable the "rtp symmetric" hack which consists of the following: after the first packet is received, the source address of the packet is set to be the destination address for all next packets. This is useful to pass-through firewalls. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yesno</em>&nbsp;</td><td>a boolean to enable or disable the feature </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad40bebc95da58087ded9a332b91a8138"></a><!-- doxytag: member="rtpsession.h::rtp_session_set_time_jump_limit" ref="ad40bebc95da58087ded9a332b91a8138" args="(RtpSession *session, int miliseconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC void rtp_session_set_time_jump_limit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>milisecs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oRTP has the possibility to inform the application through a callback registered with rtp_session_signal_connect about crazy incoming RTP stream that jumps from a timestamp N to N+some_crazy_value. This lets the opportunity for the application to reset the session in order to resynchronize, or any other action like stopping the call and reporting an error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>the rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ts_step</em>&nbsp;</td><td>a time interval in miliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a754c06f3ed87366c0dddc8f4e5481e9d"></a><!-- doxytag: member="rtpsession.h::rtp_session_signal_connect" ref="a754c06f3ed87366c0dddc8f4e5481e9d" args="(RtpSession *session, const char *signal_name, RtpCallback cb, unsigned long user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_signal_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>signal_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RtpCallback&nbsp;</td>
          <td class="paramname"> <em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>user_data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function provides the way for an application to be informed of various events that may occur during a rtp session.  is a string identifying the event, and  is a user supplied function in charge of processing it. The application can register several callbacks for the same signal, in the limit of RTP_CALLBACK_TABLE_MAX_ENTRIES. Here are name and meaning of supported signals types:</p>
<p>"ssrc_changed" : the SSRC of the incoming stream has changed.</p>
<p>"payload_type_changed" : the payload type of the incoming stream has changed.</p>
<p>"telephone-event_packet" : a telephone-event rtp packet (RFC2833) is received.</p>
<p>"telephone-event" : a telephone event has occured. This is a high-level shortcut for "telephone-event_packet".</p>
<p>"network_error" : a network error happened on a socket. Arguments of the callback functions are a const char * explaining the error, an int errno error code and the user_data as usual.</p>
<p>"timestamp_jump" : we have received a packet with timestamp in far future compared to last timestamp received. The farness of far future is set by rtp_sesssion_set_time_jump_limit() "rtcp_bye": we have received a RTCP bye packet. Arguments of the callback functions are a const char * containing the leaving reason and the user_data.</p>
<p>Returns: 0 on success, -EOPNOTSUPP if the signal does not exists, -1 if no more callbacks can be assigned to the signal type.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signal_name</em>&nbsp;</td><td>the name of a signal </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>a RtpCallback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user_data</em>&nbsp;</td><td>a pointer to any data to be passed when invoking the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af28f1230c4f1e6f77381cd4dac45c950"></a><!-- doxytag: member="rtpsession.h::rtp_session_signal_disconnect_by_callback" ref="af28f1230c4f1e6f77381cd4dac45c950" args="(RtpSession *session, const char *signal_name, RtpCallback cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORTP_PUBLIC int rtp_session_signal_disconnect_by_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__RtpSession.html">RtpSession</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>signal_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RtpCallback&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes callback function  to the list of callbacks for signal .</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a rtp session </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signal_name</em>&nbsp;</td><td>a signal name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cb</em>&nbsp;</td><td>a callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: 0 on success, a negative value if the callback was not found. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 18 Mar 2014 for oRTP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
